diff --git a/chrome/browser/ui/android/desktop_site/BUILD.gn b/chrome/browser/ui/android/desktop_site/BUILD.gn
index c1658b1ed6..f154de969f 100644
--- a/chrome/browser/ui/android/desktop_site/BUILD.gn
+++ b/chrome/browser/ui/android/desktop_site/BUILD.gn
@@ -9,6 +9,7 @@ android_library("java") {
     "java/src/org/chromium/chrome/browser/desktop_site/DesktopSiteUtils.java",
   ]
   deps = [
+    "//chrome/browser/ui/android/foldable:java",
     "//base:base_java",
     "//base:base_shared_preferences_java",
     "//chrome/browser/flags:java",
diff --git a/chrome/browser/ui/android/desktop_site/java/src/org/chromium/chrome/browser/desktop_site/DesktopSiteUtils.java b/chrome/browser/ui/android/desktop_site/java/src/org/chromium/chrome/browser/desktop_site/DesktopSiteUtils.java
index 13dd08d6d3..8b9e1d306c 100644
--- a/chrome/browser/ui/android/desktop_site/java/src/org/chromium/chrome/browser/desktop_site/DesktopSiteUtils.java
+++ b/chrome/browser/ui/android/desktop_site/java/src/org/chromium/chrome/browser/desktop_site/DesktopSiteUtils.java
@@ -33,6 +33,7 @@ import org.chromium.components.content_settings.ContentSettingsType;
 import org.chromium.components.content_settings.PrefNames;
 import org.chromium.components.prefs.PrefService;
 import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.chrome.browser.foldable.FoldablePostureController;
 import org.chromium.ui.base.DeviceFormFactor;
 import org.chromium.ui.display.DisplayAndroid;
 import org.chromium.ui.display.DisplayAndroidManager;
@@ -275,6 +276,21 @@ public class DesktopSiteUtils {
         if (!isRequestDesktopSiteContentSettingsGlobal(profile, url)) {
             return false;
         }
+
+        // Foldable device posture-based mode switching.
+        // When folded, use mobile mode. When unfolded, use desktop mode.
+        if (FoldablePostureController.isFoldableDevice()) {
+            FoldablePostureController postureController = FoldablePostureController.getInstance();
+            if (postureController.isFolded()) {
+                // Device is folded - use mobile mode
+                return true;
+            } else if (postureController.isUnfolded()) {
+                // Device is unfolded - use desktop mode
+                return false;
+            }
+            // Unknown posture - fall through to width-based detection
+        }
+
         // Try the window attributes width first.
         // PCCT has its width stored in window attributes.
         int widthPixels = -1;
diff --git a/chrome/browser/ui/android/foldable/BUILD.gn b/chrome/browser/ui/android/foldable/BUILD.gn
new file mode 100644
index 0000000000..bab9c00b1e
--- /dev/null
+++ b/chrome/browser/ui/android/foldable/BUILD.gn
@@ -0,0 +1,18 @@
+# Copyright 2026 The Chromium Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/android/rules.gni")
+
+android_library("java") {
+  sources = [
+    "java/src/org/chromium/chrome/browser/foldable/FoldablePostureController.java",
+  ]
+
+  deps = [
+    "//base:base_java",
+    "//build/android:build_java",
+    "//third_party/android_sdk:android_window_extensions_java",
+    "//third_party/androidx/local_modifications/window:window_util_java",
+  ]
+}
diff --git a/chrome/browser/ui/android/foldable/java/src/org/chromium/chrome/browser/foldable/FoldablePostureController.java b/chrome/browser/ui/android/foldable/java/src/org/chromium/chrome/browser/foldable/FoldablePostureController.java
new file mode 100644
index 0000000000..db330be79c
--- /dev/null
+++ b/chrome/browser/ui/android/foldable/java/src/org/chromium/chrome/browser/foldable/FoldablePostureController.java
@@ -0,0 +1,210 @@
+// Copyright 2026 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.foldable;
+
+import android.content.Context;
+import android.os.Build;
+
+import androidx.window.extensions.core.util.function.Consumer;
+import androidx.window.extensions.layout.DisplayFeature;
+import androidx.window.extensions.layout.FoldingFeature;
+import androidx.window.extensions.layout.WindowLayoutInfo;
+
+import org.chromium.base.ContextUtils;
+import org.chromium.base.DeviceInfo;
+import org.chromium.base.Log;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.window.WindowApiCheck;
+import org.chromium.window.WindowUtil;
+
+import java.util.List;
+
+/**
+ * Controller for tracking foldable device posture changes.
+ * Provides methods to query current fold state and receive posture change callbacks.
+ */
+@NullMarked
+public class FoldablePostureController {
+    private static final String TAG = "FoldablePosture";
+
+    /** Posture states for foldable devices. */
+    public enum Posture {
+        UNKNOWN,
+        FLAT,      // Device is fully unfolded (tablet-like)
+        HALF_OPEN, // Device is partially folded (tent/laptop mode)
+        FOLDED     // Device is fully folded (phone-like)
+    }
+
+    /** Listener interface for posture changes. */
+    public interface PostureChangeListener {
+        void onPostureChanged(Posture newPosture);
+    }
+
+    private static @Nullable FoldablePostureController sInstance;
+    private static final Object sLock = new Object();
+
+    private Posture mCurrentPosture = Posture.UNKNOWN;
+    private @Nullable Consumer<WindowLayoutInfo> mWindowLayoutInfoConsumer;
+    private @Nullable PostureChangeListener mListener;
+    private boolean mIsTracking;
+
+    /** Get the singleton instance. */
+    public static FoldablePostureController getInstance() {
+        synchronized (sLock) {
+            if (sInstance == null) {
+                sInstance = new FoldablePostureController();
+            }
+            return sInstance;
+        }
+    }
+
+    private FoldablePostureController() {}
+
+    /**
+     * Check if the device is a foldable.
+     * @return true if device has foldable capabilities.
+     */
+    public static boolean isFoldableDevice() {
+        return DeviceInfo.isFoldable();
+    }
+
+    /**
+     * Get the current posture.
+     * @return Current posture state.
+     */
+    public Posture getCurrentPosture() {
+        return mCurrentPosture;
+    }
+
+    /**
+     * Check if device is currently in folded state (phone-like mode).
+     * @return true if folded or half-open, false if flat/unfolded.
+     */
+    public boolean isFolded() {
+        return mCurrentPosture == Posture.FOLDED || mCurrentPosture == Posture.HALF_OPEN;
+    }
+
+    /**
+     * Check if device is in flat/unfolded state (tablet-like mode).
+     * @return true if flat/unfolded.
+     */
+    public boolean isUnfolded() {
+        return mCurrentPosture == Posture.FLAT;
+    }
+
+    /**
+     * Start tracking posture changes.
+     * @param context The context to use for tracking.
+     * @param listener Callback for posture changes.
+     */
+    public void startTracking(Context context, @Nullable PostureChangeListener listener) {
+        if (!isFoldableDevice()) {
+            Log.d(TAG, "Not a foldable device");
+            return;
+        }
+
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
+            Log.d(TAG, "API level too low for window extensions");
+            return;
+        }
+
+        if (!WindowApiCheck.isAvailable()) {
+            Log.d(TAG, "Window extensions API not available");
+            return;
+        }
+
+        if (mIsTracking) {
+            Log.d(TAG, "Already tracking posture");
+            return;
+        }
+
+        mListener = listener;
+        mIsTracking = true;
+
+        try {
+            mWindowLayoutInfoConsumer = this::onWindowLayoutInfoChanged;
+            WindowUtil.addWindowLayoutInfoListener(context, mWindowLayoutInfoConsumer);
+            Log.d(TAG, "Started foldable posture tracking");
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to start posture tracking", e);
+            mIsTracking = false;
+            mWindowLayoutInfoConsumer = null;
+        }
+    }
+
+    /**
+     * Stop tracking posture changes.
+     */
+    public void stopTracking() {
+        if (!mIsTracking || mWindowLayoutInfoConsumer == null) {
+            return;
+        }
+
+        try {
+            WindowUtil.removeWindowLayoutInfoListener(mWindowLayoutInfoConsumer);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to stop posture tracking", e);
+        }
+
+        mWindowLayoutInfoConsumer = null;
+        mListener = null;
+        mIsTracking = false;
+        Log.d(TAG, "Stopped foldable posture tracking");
+    }
+
+    private void onWindowLayoutInfoChanged(WindowLayoutInfo windowLayoutInfo) {
+        FoldingFeature foldingFeature = getFirstFoldingFeature(windowLayoutInfo);
+        Posture newPosture = determinePosture(foldingFeature);
+
+        if (newPosture != mCurrentPosture) {
+            Posture oldPosture = mCurrentPosture;
+            mCurrentPosture = newPosture;
+            Log.d(TAG, "Posture changed: " + oldPosture + " -> " + newPosture);
+
+            if (mListener != null) {
+                mListener.onPostureChanged(newPosture);
+            }
+        }
+    }
+
+    private @Nullable FoldingFeature getFirstFoldingFeature(WindowLayoutInfo windowLayoutInfo) {
+        List<DisplayFeature> features = windowLayoutInfo.getDisplayFeatures();
+        if (features.isEmpty()) {
+            return null;
+        }
+
+        for (DisplayFeature feature : features) {
+            if (feature instanceof FoldingFeature) {
+                return (FoldingFeature) feature;
+            }
+        }
+        return null;
+    }
+
+    private Posture determinePosture(@Nullable FoldingFeature feature) {
+        if (feature == null) {
+            // No folding features - could be fully folded (cover screen) or non-foldable display
+            // Default to FOLDED for safety on foldable devices
+            return isFoldableDevice() ? Posture.FOLDED : Posture.UNKNOWN;
+        }
+
+        int state = feature.getState();
+        if (state == FoldingFeature.STATE_FLAT) {
+            return Posture.FLAT;
+        } else if (state == FoldingFeature.STATE_HALF_OPENED) {
+            return Posture.HALF_OPEN;
+        }
+        return Posture.UNKNOWN;
+    }
+
+    /**
+     * Force a specific posture (for testing).
+     * @param posture The posture to set.
+     */
+    public void setPostureForTesting(Posture posture) {
+        mCurrentPosture = posture;
+    }
+}
